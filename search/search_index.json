{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>C is a programming language closely associated with UNIX and Linux. C was inspired by the B language, which was written by Ken Thompson in 1970 for the first UNIX system on the PDP-7.</p> C standards <p>For many years, the definition of C was the reference manual in the first edition of The C Programming Language by Brian Kernighan and Dennis Ritchie (Kernighan).</p> <p>In 1983, ANSI established a committee to provide a modern, comprehensive definition of C which was completed late in 1988, referred to as ANSI C or standard C. ANSI C incorporates small changes to the language, incorporating enumerations, single-precision floating-point computations, and elaborating the preprocessor. Additionally, a library was defined to accompany C (\"the standard library\") to incorporate higher-level functions to facilitate file access, etc.</p> <p>The C standard is now maintained and developed by the ISO/IEC international standardization working group for the C programming language, known as WG14 (short for ISO/IEC JTC1/SC22/WG14). In 1999 the ISO C standard was updated and approved (ISO/IEC 9899:1999, referred as C99) to improve support for applications that perform numerical processing. The changes don't affect POSIX interfaces relevant to system programming, except for the addition of the restrict keyword which tells the compiler which pointer references can be optimized by indicating that the object to which the pointer refers is accessed in the functino only via that pointer. Technical corrigenda have been published in 2001, 2004, and 2007. Successively newer versions of C have been referred to as C11, C18, and C22.</p> Inspect compiler's version of C<pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    #if __STDC_VERSION__ &gt;= 201710L\n        printf(\"C18\\n\");\n    #elif __STDC_VERSION__ &gt;= 201112L\n        printf(\"C11\\n\");\n    #elif __STDC_VERSION__ &gt;= 199901L\n        printf(\"C99\\n\");\n    #else \n        printf(\"C89/C90\\n\");\n    #endif\n    return 0;\n}\n</code></pre> <p>A specific C version can be specified to the compiler with -std</p> <pre><code># Specify 2011 version of the C standard\ngcc -std=c11 # c99, c90, c89 are also available\n</code></pre> POSIX.1 <p>POSIX (Portable Operating system Interface) is a family of standards initially developed by the IEEE. The 1988 version of POSIX, IEEE Standard 1003.1-1988, saw minor revisions and was submitted to ISO as ISO/IEC 9945-1:1990 (also IEEE 1003.1-1990), commonly referred to as POSIX.1.</p> <p>In 1996 the pthreads interfaces for multithreaded programming were added to the standard, which was published as ISO/IEC 9945-1:1996. Additional interfaces were added in 1999, 2000, 2001, 2004, and 2008 which was approved by ISO as ISO/IEC 9945:2009. </p> <p>The POSIX.1 standard includes the 24 ISO C headers as well as others.</p> main() signature<pre><code>int main(int argc, char** argv);\n</code></pre> <p>main() is the canonical entrypoint for C and C++ programs. It returns a signed integer and takes two arguments.</p> <ul> <li>argc argument count</li> <li>argv argument vector</li> </ul> <p>Header files are included by using the #include C preprocessor directive. Headers provided in angle brackets are to be found in the system-defined header path (/usr/include).</p> <pre><code>#include &lt;stdio.h&gt;\n</code></pre> Installing header files <p>Compiling even simple programs will fail if they include dependencies on header files that are not present.</p> <pre><code># Ubuntu\napt install -y build-essential\n\n# Note that this not yet possible on WSL2 without using a custom compiled kernel.\napt install -y linux-header-$(uname -r)\n</code></pre>"},{"location":"#text-input","title":"Text input","text":"<p>A trivial example showing how a character stream can be accepted and immediately echoed.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char c;\n    c = getchar();\n    while (c!=EOF) {\n        putchar(c);\n        c = getchar();\n    }\n} // Kernighan 16   \n</code></pre> <p>A similarly trivial example shows how a stream of characters can be counted. Note that the enter press is part of the character stream and cannot be omitted, even if you hit ++Ctrl+D++ to insert EOF.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    long nc;\n    nc = 0;\n    while (getchar() != EOF)\n        ++nc;\n    printf(\"%ld\\n\", nc);\n} // Kernighan 18\n</code></pre> <p>A stranger-looking but more interesting implementation is possible by declaring the index variable of the for loop outside of the loop and using it to keep track of the character stream.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    double nc;\n\n    for (nc = 0; getchar() != EOF; ++nc)\n        ;\n    printf(\"%.0f\\n\", nc);\n} // Kernighan 18\n</code></pre> <p>Here, lines of input are counted instead of characters.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    int c, nl;\n\n    nl = 0;\n    while ((c = getchar()) != EOF)\n        if (c == '\\n')\n            ++nl;\n    printf(\"%d\\n\", nl);\n    return 0;\n} // Kernighan 19\n</code></pre> <p>Here, a more elaborate example stores the longest line of all the lines typed in. Note the example includes a symbolic constant and multiple function definitions, including function declarations at the top.</p> <pre><code>#include &lt;stdio.h&gt;\n#define MAXLINE 1000\n\nvoid copy(char to[], char from[]);\nint getline_(char to[], int maxline);\n\nint main(int argc, char const *argv[])\n{\n    int len, max;\n    char line[MAXLINE], longest[MAXLINE];\n\n    max = 0;\n    while ((len = getline_(line, MAXLINE)) &gt; 0)\n        if (len &gt; max) {\n            max = len;\n            copy(longest, line);\n        }\n    if (max &gt; 0) printf(\"%s\", longest);\n    return 0;\n}\n\nint getline_(char s[], int lim) {\n    int c, i;\n\n    for (i = 0; i &lt; lim - 1 &amp;&amp; (c = getchar()) != EOF &amp;&amp; c != '\\n'; ++i)\n        s[i] = c;\n    if (c == '\\n') {\n        s[i] = c;\n        ++i;\n    }\n    s[i] = '\\0';\n    return i;\n} \n\n\nvoid copy(char to[], char from[])\n{\n    int i;\n\n    i = 0;\n    while ((to[i] = from[i]) != '\\0')\n        ++i;\n} // Kernighan 29\n</code></pre>"},{"location":"#types","title":"Types","text":"Constants and literals <p>Note that in Kernighan, constant is used as a synonym for literal.</p> <p>int can be short (usually 16-bit) or long (32-bit). An integer literal ending in l or L is a long integer.</p> <p>Floating-point literals by default are of type long double or double unless suffixed by f or F, which indicate a float. Long doubles can be explicitly defined by appending l or L to the literal.</p> <p>Hexadecimal literals can be defined by prepending 0x or 0X, and octals can be defined by prepending 0 alone. These can also be explicitly defined as float or long by appending the appropriate letter.</p> <p>Finally, literals can be appended with u or U to make them unsigned.</p> <pre><code>0L      // long of value 0\n0x1f    // float of value 31 in hexadecimal\n0xFUL   // unsigned long of value 15\n</code></pre> <p>Single characters are provided in single quotes and are equivalent to the integer value of their ASCII code. Some characters can be expressed by escape sequences like \\n, \\t, etc. Characters can also be represented by octal or hexadecimal digits.</p> <pre><code>'a'\n'\\n'\n'\\013', '\\xb'   // ASCII vertical tab\n'\\007', '\\x7'   // ASCII bell character\n'\\0'            // null character, used to terminate char arrays\n</code></pre> <p>typedef facilitates the creation of new data type names, which are conventionally capitalized. It is similar to #define, except that it is interpreted by the compiler. These new types are self-documenting and parameterize the program against portability problems (i.e. in the standard library, size_t is a synonym of unsigned int and ptrdiff_t is a synonym of int). Most standard system data types have names ending in _t, and mostly they are declared in the header file sys/types.h (see TLPI p. 64-65 for a selected list of system data types).</p> <pre><code>// Create a complex struct definition\ntypedef struct student {\n    char name[20];\n    float midterm1;\n    float midterm2;\n    float final_exam;\n    float final_grade;\n} Student;\n</code></pre> <p>Types can be cast to other types by preceding the variable with the cast data type in parentheses, for example in this code which convertes a pid_t (int) to a long:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    pid_t mypid;\n\n    mypid = getpid();\n    printf(\"My PID is %ld\\n\", (long) mypid);\n    return 0;\n}\n</code></pre>"},{"location":"#glibc","title":"glibc","text":"<p>The most commonly used implementation of the standard C library on Linux is the GNU C library or glibc (alternatives with smaller memory requirements for use in embedded devices include uClibc and diet libc). The glibc shared library file can be found at /lib64/libc.so.6 or /usr/lib/libc.so.6, and running it as an executable from the command-line will output the glibc version.</p> <pre><code>/lib64/libc.so.6 # (1)\n</code></pre> <ol> <li>Output<pre><code>GNU C Library (GNU libc) stable release version 2.38.\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\nCompiled by GNU CC version 13.2.1 20230801.\nlibc ABIs: UNIQUE IFUNC ABSOLUTE\nMinimum supported kernel: 4.4.0\nFor bug reporting instructions, please see:\n&lt;https://bugs.archlinux.org/&gt;.\n</code></pre></li> </ol> <p>ldd can be used to find the location of the glibc shared library on a running distribution.</p> <pre><code>ldd /usr/bin/bash # (1)\n</code></pre> <ol> <li>Output<pre><code>    linux-vdso.so.1 (0x00007fff82feb000)\n    libreadline.so.8 =&gt; /usr/lib/libreadline.so.8 (0x00007f2151db3000)\n    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f2151a00000)\n    libncursesw.so.6 =&gt; /usr/lib/libncursesw.so.6 (0x00007f2151d3c000)\n    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f2151f4e000)\n</code></pre></li> </ol> <p>glibc defines the function gnu_get_libc_version() that returns the library version as a string. Two symbolic constants that encode the version of the library as integers are also defined: __GLIBC__ and __GLIBC_MINOR__.</p> <pre><code>#include &lt;gnu/libc-version.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    printf(\"Using gnu_get_libc_version(): %s\\n\", gnu_get_libc_version());\n    printf(\"Using symbolic constnats: %d.%d\\n\", __GLIBC__, __GLIBC_MINOR__);\n    return 0;\n}\n</code></pre>"},{"location":"#error-handling","title":"Error handling","text":"<p>When system calls fail, they typically set the global integer variable errno to a nonzero value. This value is not reset to zero by subsequent successful calls.</p> <p>Several functions exist in the standard library to provide error messaging capability:</p> <ul> <li>perror() (stdlib.h) print an error message</li> <li>strerror() (string.h) interprets the error number passed in as its argument</li> <li>errno (errno.h)</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    FILE* fptr;\n\n    fptr = fopen(\"/home/jasper/none\", \"r\");\n    if (fptr == NULL) {\n        perror(\"fopen\");\n        printf(\"errno: %d\\n\", errno);\n        printf(\"strerror: %s\", strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n    else\n        fclose(fptr);\n    exit(EXIT_SUCCESS);\n}\n</code></pre> <p>Library functions report errors in one of several ways:</p> <ul> <li>Return -1 with errno indicating the specific error (e.g. open())</li> <li>Return NULL with errno indicating the specific error (e.g. fopen())</li> <li>Other library functions don't use errno at all</li> </ul>"},{"location":"#data-organization","title":"Data organization","text":"<p>Use structs to organize data.</p>"},{"location":"#command-line-parsing","title":"Command-line parsing","text":"<p>The functions atoi(), atol(), and atoll() (stdlib.h) allow conversion of strings passed in from the command-line to integers, longs, and long longs.</p>"},{"location":"cli/","title":"Command-line parsing","text":"<p>There are a variety of ways to parse command-line arguments and options for creating a CLI utility, but the most immediate solution is getopt() (unistd.h).</p> <ul> <li>argp from the GNU C library which is more complex but also more powerful</li> <li>argparse inspired by Python's argparse module</li> <li>opt</li> </ul>"},{"location":"cli/#getopt","title":"getopt","text":"<pre><code>// Parse command-line arguments and options, returning -1 on error\nint     getopt  (int argc, char* argv[], const char* optstring)\n</code></pre> <p>In getopt, all options are concatenated together in the optstring. Options that take arguments are suffixed by colon (:).</p> <p>There are two potential errors that may occur as getopt() processes an option list:</p> <ul> <li>An option not specified in optstring is encountered.</li> <li>Argument not supplied to an option that expects one.</li> </ul> <p>By default, getopt() prints an appropriate error message on STDERR and returns the character ? as the function result, assigning the erroneous character to the global variable optopt. However, if the global variable opterr is set to 0, the error message can be suppressed and custom error handling can be implemented. Alternatively, error messages can be suppressed by prepending colon (:) to the optstring, which suppresses error messages and also returns colorn (:) as the function result in case of a missing argument.</p> <p>A command line is parsed by repeated calls to getopt in a while loop. The call to getopt is placed as the index of a while loop which continues until the function returns -1. A switch statement is used to dispatch on the return value from getopt.</p> <p>This trivial example shows the basic structure of the syntax, but any option will return an error.</p> <pre><code>#include &lt;unistd.h&gt;\n\nint main(int argc, char** argv)\n{\n    int g;\n\n    while ((g = getopt (argc, argv, \"\")) != -1)\n    switch (g) \n    {\n        default:\n            return 1;\n    }\n    return 0;\n}\n</code></pre> <p>In this example, only a single command-line option is accepted. Notice an arm has been implemented for question mark (?) which will be returned by getopt() in case of an unknown option - any option except -a.</p> <pre><code>#include &lt;unistd.h&gt;\n\nint main(int argc, char** argv)\n{\n    int g;\n\n    while ((g = getopt (argc, argv, \"a\")) != -1)\n    switch (g) \n    {\n        case 'a':\n            break;\n        case '?':\n            printf(\"Unknown option\\n\");\n        default:\n            return 1;\n    }\n    return 0;\n}\n</code></pre> <p>The following example elaborates further, implementing option -b which needs an argument. Because optstring is prepended by a colon (:), an additional arm is implemented to handle the error when an argument is not provided to -b.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char** argv)\n{\n    int g;\n\n    while ((g = getopt (argc, argv, \":ab:\")) != -1)\n    switch (g) \n    {\n        case 'a':\n            break;\n        case 'b':\n            printf(\"Hello, %s!\\n\", optarg);\n        case '?':\n            printf(\"Unknown option\");\n            return 1;\n        case ':':\n            printf(\"Missing argument\");\n            return 1;\n        default: \n            printf(\"We should never get here\");\n            return 1;\n    }\n    return 0;\n}\n</code></pre> <p>This example provided by GNU shows how the switch statement can assign values to local variables before exiting the while loop and proceeding with execution. Note that the question mark (?) case is what will process any unknown option, and the switch should never reach the default arm.</p> <pre><code>/*\nExample of parsing arguments with getopt\nFrom https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html\n*/\n\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint\nmain (int argc, char **argv)\n{\n  int aflag = 0;\n  int bflag = 0;\n  char *cvalue = NULL;\n  int index;\n  int c;\n\n  opterr = 0;\n\n\n  while ((c = getopt (argc, argv, \"abc:\")) != -1)\n    switch (c)\n      {\n      case 'a':\n        aflag = 1;\n        break;\n      case 'b':\n        bflag = 1;\n        break;\n      case 'c':\n        cvalue = optarg;\n        break;\n      case '?':\n        if (optopt == 'c')\n          fprintf (stderr, \"Option -%c requires an argument.\\n\", optopt);\n        else if (isprint (optopt))\n          fprintf (stderr, \"Unknown option `-%c'.\\n\", optopt);\n        else\n          fprintf (stderr,\n                   \"Unknown option character `\\\\x%x'.\\n\",\n                   optopt);\n        return 1;\n      default:\n        abort ();\n      }\n\n\n  printf (\"aflag = %d, bflag = %d, cvalue = %s\\n\",\n          aflag, bflag, cvalue);\n\n  for (index = optind; index &lt; argc; index++)\n    printf (\"Non-option argument %s\\n\", argv[index]);\n  return 0;\n}\n</code></pre>"},{"location":"compile/","title":"Compilation","text":"<p>Linking is performed by the separate linker program ld, but is normally invoked indirectly by gcc to ensure the correct options and libraries are used.</p>"},{"location":"compile/#gcc","title":"gcc","text":"<pre><code># Specify 2011 version of the C standard\ngcc -std=c11 # c99, c90, c89 are also available\n\n# Compile main.c, displaying all warnings\ngcc -Wall\n\n# Compiling with ncurses library\ngcc -lncurses\n\n# Compile a program using pthread\ngcc -lpthread\n</code></pre> <p>pkg-config returns directory names, which gcc uses to ensure all header files are available.</p> <p>Here, pkg-config appends options to the command-line used by the linker including library directory path extensions and a list of libraries needed for linking to the executable.</p> <pre><code># Compiling a GTK program written in C\ngcc -Wall -g $(pkg-config --cflags gtk+-3.0) $(pkg-config --libs gtk+-3.0)\n</code></pre> Various options<pre><code># Output extra information for use by a debugger with -g\ngcc -g\n\n# Skip linking entirely with -c\ngcc -c\n</code></pre>"},{"location":"file/","title":"File handling","text":"<p>A distinguishing feature of the I/O model on UNIX systems is the concept of universality of I/O, meaning the same system calls are used to perform I/O on files and devices. File I/O system calls refer to open files using a file descriptor, a non-negative integer typically obtained by a call to open().</p> File descriptors <p>UNIX shells conventionally associate file descriptors 0, 1, and 2 with STDIN, STDOUT, and STDERR respectively. However this is not a feature of the UNIX kernel.</p> <p>The symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO are defined in unistd.h:</p> <pre><code>// The file descriptors for STDIN, STDOUT, and STERR are defined as symbolic constants in unistd.h.\n\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    printf(\"Value of STDIN_FILENO: %d\\n\", STDIN_FILENO);\n    printf(\"Value of STDOUT_FILENO: %d\\n\", STDOUT_FILENO);\n    printf(\"Value of STDERR_FILENO: %d\\n\", STDERR_FILENO);\n    return 0;\n}\n// (1)\n</code></pre> <ol> <li>Output: <pre><code>Value of STDIN_FILENO: 0\nValue of STDOUT_FILENO: 1\nValue of STDERR_FILENO: 2\n</code></pre></li> </ol>"},{"location":"file/#stdio","title":"stdio","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    char* filename;\n    FILE* fptr;\n\n    fptr = fopen(\"/home/jasper/hw\", \"r+\");\n    if (fptr == NULL) {\n        perror(\"fopen\");\n        printf(\"%d\\n\", errno);\n        exit(EXIT_FAILURE);\n    }\n    else {\n        fputs(\"Hello, World!\", fptr);\n        fclose(fptr);\n        exit(EXIT_SUCCESS);\n    }\n}\n</code></pre> <p>A variety of techniques and functions exist to implement file handling in C, but fopen() appears to be the most common, defined in stdio.</p> <p>The FILE macro is used to create the file offset (also called the file pointer), a reference to a particular position in the opened file, and is also defined in stdio.</p> <p>fopen() returns a NULL in case of an error, and error handling in C in general appears to rely on handling NULL returns in conditional statements as illustrated below. Here, passing r as the value for mode indicates that the function will return NULL if the file doesn't exist.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    FILE* fptr;\n\n    fptr = fopen(\"/home/jasper/none\", \"r\");\n    if (fptr == NULL) {\n        printf(\"Nonexistent file failed to open.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    exit(EXIT_SUCCESS);\n} // From https://www.geeksforgeeks.org/basics-file-handling-c/#file-pointer-in-c\n</code></pre> <p>In fact, perror() is provided for printing error messages. Here, printf is replaced by perror (even though it won't be reached) and a mode of w is provided to fopen(), which will create a file even if one doesn't exist.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    FILE* fptr;\n\n    fptr = fopen(\"/home/jasper/hw\", \"w\");\n    if (fptr == NULL) {\n        perror(\"fopen\");\n        exit(EXIT_FAILURE);\n    }\n    else    \n        printf(\"File created successfully.\\n\");\n    exit(EXIT_SUCCESS);\n} // From https://www.geeksforgeeks.org/basics-file-handling-c/#file-pointer-in-c\n</code></pre> <p>In this example, a file is not only opened but written to in a Hello, World!.  The r+ mode indicates that the file is opened in both read and write mode, but will not be created if it doesn't exist.</p> <p>Note the use of fclose() which is necessary to release the memory used by the opened file before closing the program.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    char* filename;\n    FILE* fptr;\n\n    fptr = fopen(\"/home/jasper/hw\", \"r+\");\n    if (fptr == NULL) {\n        perror(\"fopen\");\n        printf(\"%d\\n\", errno);\n        exit(EXIT_FAILURE);\n    }\n    else {\n        fputs(\"Hello, World!\", fptr);\n        fclose(fptr);\n        exit(EXIT_SUCCESS);\n    }\n}\n</code></pre> <p>This more sophisticated example shows an implementation of how to read a file with the fgets() function, also defined in stdio.h, which gets the file line by line.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    FILE* fptr;\n    char buffer[50];\n\n    fptr = fopen(\"/home/jasper/.bashrc\", \"r\");\n    if (fptr == NULL) \n        printf(\".bashrc file failed to open.\\n\");\n    else {\n        printf(\"The file is now opened.\\n\");\n        while (fgets(buffer, 50, fptr) != NULL) {\n            printf(\"%s\", buffer);\n        }\n        fclose(fptr);\n        printf(\".bashrc is now closed.\");\n    }\n\n    return 0;\n} // From https://www.geeksforgeeks.org/basics-file-handling-c/#file-pointer-in-c\n</code></pre>"},{"location":"file/#fcntl","title":"fcntl","text":"<p>The system calls provided in fcntl.h are older, lower-level, and more complex. But they form the basis of the higher-level calls used in other libraries like stdlib.h.</p> <p>This example illustrates how open() and close() (fcntl.h) can be used to open an existing file for reading only while properly handling error in case the file is not accessible.</p> <pre><code>/*\nOpen and close a file, with proper error handling.\n*/\n\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    int fd;\n\n    fd = open(\"/home/jasper/.bashrc\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    else \n        printf(\"File opened successfully\\n\");\n        close(fd);\n        exit(EXIT_SUCCESS);\n}\n</code></pre> <p>Here, a brief Hello, World! message is written to the file using write() (unistd.h). Notice the flag has been changed to O_WRONLY, which will allow the program to write to an existing file but not to create one.</p> <pre><code>/*\nWrite Hello, World! to an existent file\n*/\n\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    int fd;\n\n    fd = open(\"/home/jasper/hw\", O_WRONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    else \n        write(fd, \"Hello, World!\\n\", 14);\n        close(fd);\n        exit(EXIT_SUCCESS);\n}\n</code></pre> <p>A bitwise OR operator (|) here is provided to combine O_CREAT with O_WRONLY, which will allow the file to be created if it doesn't exist.</p> <pre><code>/*\nWrite Hello, World! to a file, or create one if it doesn't exist\n*/\n\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    int fd;\n\n    fd = open(\"/home/jasper/hw\", O_CREAT | O_WRONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    else \n        write(fd, \"Hello, World!\\n\", 14);\n        close(fd);\n        exit(EXIT_SUCCESS);\n}\n</code></pre> <p>An elaborated example shows how strlen() (string.h) can be incorporated into the call to write().</p> <pre><code>/*\nWrite Hello, World! to a file, or create one if it doesn't exist\n*/\n\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    int fd;\n    char* message = \"Hello, World!\\n\";\n\n    fd = open(\"/home/jasper/hw\", O_CREAT | O_WRONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    else \n        write(fd, message, strlen(message));\n        close(fd);\n        exit(EXIT_SUCCESS);\n}\n</code></pre> <p>Writes can be appended to the file by adding the O_APPEND flag.</p> <pre><code>/*\nAppend Hello, World! to a file\n*/\n\n#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    int fd;\n\n    fd = open(\"/home/jasper/hw\", O_APPEND | O_CREAT | O_WRONLY );\n    if (fd == -1) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    else \n        write(fd, \"Hello, World!\\n\", 14);\n        close(fd);\n        exit(EXIT_SUCCESS);\n}\n</code></pre>"},{"location":"file/#tasks","title":"Tasks","text":""},{"location":"file/#cat","title":"cat","text":"<p>A simple cat clone is possible using the functions provided in stdlib.</p> <p>All arguments to the program are interpreted as filenames. The fopen call returns a file pointer which is used in the rest of the file handling functions. fseek is used to seek to the end of the file, then ftell returns the position of the seek head in number of bytes from the beginning of the file (i.e., the file size).</p> <p>A buffer precisely sized to be the same number of bytes as the file is allocated from memory and the seek head is returned to the beginning. fread is used to read the file contents into the buffer, and then fwrite is used to read from memory to stdout.</p> <p>Using fclose and free, the file pointer and buffer are released before terminating the program successfully.</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nchar *buffer;\n\nvoid read(char* filename) {\n    FILE *fp;\n    fp = fopen(filename, \"r\");\n    if (fp != NULL) {\n        fseek(fp, 0L, SEEK_END);\n        long s = ftell(fp);\n        rewind(fp);\n        buffer = malloc(s);\n        fread(buffer, s, 1, fp);\n        fwrite(buffer, s, 1, stdout);\n        if (fp != NULL) fclose(fp);\n        free(buffer);\n    }\n}\n\nint main(int argc, char** argv) {\n    int f;\n    for(f=1; f&lt;argc; f++) {\n        read(argv[f]);\n    }\n    exit(EXIT_SUCCESS);\n}\n</code></pre>"},{"location":"hw/","title":"Hello, World!","text":"<p>Naive<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello World\\n\");\n}\n</code></pre> Parameterized<pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char** argv) {\n    printf(\"Hello, %s!\\n\", argv[1]);\n}\n</code></pre> Multiple arguments<pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char** argv) {\n    int f;\n    for(f=1; f&lt;argc; f++) {\n        printf(\"Hello, %s!\\n\", argv[f]);\n    }\n}\n</code></pre></p> <p>More header files are needed for the functions necessary to write to a file.</p> <ul> <li>fcntl.h for open() and the enums O_WRONLY and O_CREAT</li> <li>unistd.h for close(), write()</li> </ul> <pre><code>\n</code></pre> <p>Note that the write() functions needs an argument specifying the length of the string.</p> <p>A parameterized implementation (also somewhat more graceful) is possible using fprintf from the standard library, which also provides EXIT_SUCCESS macro.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main (int c, char** argv) {\n   FILE* fp;\n\n   fp = fopen (\"/home/jasper/hw\", \"w+\");\n   fprintf(fp, \"Hello, %s!\\n\", argv[1]);\n   fclose(fp);\n   exit(EXIT_SUCCESS);\n}\n</code></pre> <p>Here the default filename is defined in symbolic constant, implementing good practice in not burying magic values within the body of the code. Some error handling is incorporated in case the file is not read (i.e. fopen() returns NULL).</p> <pre><code>// Need to change this into a cat clone\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define FILENAME \"hw\"\n\nint main (int c, char** argv) {\n   FILE* fp;\n\n   fp = fopen (FILENAME, \"r\");\n   if (fp == NULL) {\n      printf(\"Error opening file.\\n\");\n      exit(EXIT_FAILURE);\n   }\n   else {\n      printf(\"File opened successfully!\\n\");\n      fclose(fp);\n   }\n   exit(EXIT_SUCCESS);\n}\n</code></pre> <p>Here, the example is elaborated so that #define is used to create a default value for the filename which is overridden by the first argument.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define FILENAME \"/home/jasper/hw\"\n\nint main(int argc, char** argv) {\n    char* filename;\n    FILE* fptr;\n\n    if (argc == 1)\n        filename = FILENAME;\n    else\n        filename = argv[1];\n    fptr = fopen(filename, \"w\");\n    if (fptr == NULL) {\n        printf(\"Error opening file.\\n\");\n        exit(1);\n    }\n    else {\n        fprintf(fptr, \"Hello, World!\\n\");\n        fclose(fptr);\n    }\n    exit(EXIT_SUCCESS);\n}   \n</code></pre>"},{"location":"Libraries/fcntl.h/","title":"fcntl.h","text":"<p>The open(), close(), read(), and write() syscalls form the heart of low-level file I/O in Linux.</p> <pre><code>// Set an opened file's offset, returns new offset position or -1 on error\noff_t   lseek   (int fd, off_t offset, int whence);\n\n// Open an existing file or create and open a new file, returns -1 on error\nint     open    (const char* path, int flags, ... /* mode_t mode */ );\n\nint     openat  (int fd, const char* path, int oflag, ... /* mode_t mode */ );\n\n// Returns number of bytes read, 0 on EOF, or -1 on error\nssize_t read    (int fd, void* buffer, size_t count);\n</code></pre>"},{"location":"Libraries/fcntl.h/#open","title":"open","text":"<p>The flags argument is a bit mask that specifies the access mode for the file using one of 18 symbolic constants that are bitwise ORed (|) together (TLPI p. 74, APUE p. 62-65).</p>"},{"location":"Libraries/fcntl.h/#openat","title":"openat","text":"<p>openat() is one of a class of functions aded to the latest version of POSIX.1 to allow threads a way to use relative pathnames to open files in directories other than the current working directory as well as a way to avoid time-of-check-to-time-of-use (TOCTTOU) errors. These errors refer to the concern that if a second file-based function call is made that is dependent on an earlier one, the file can change between the two calls leading to an error.</p>"},{"location":"Libraries/fcntl.h/#lseek","title":"lseek","text":"History <p>The l in lseek was short for long integer, a relic of a period before the introduction of the off_t type.</p> <p>lseek() adjusts the file offset of the open file. (APUE p. 67).</p> <p>The interpretation of the offset argument depends on the the value of whence, but in all cases the value is added:</p> <ul> <li>SEEK_SET (0) from the beginning of the file</li> <li>SEEK_CUR (1) from the current offset position</li> <li>SEEK_END (2) size of the file (i.e. a positive offset would set the offset position beyond the current EOF)</li> </ul> <p>Note that because off_t is a signed data type and only positive offsets are accepted for regular files, the maximum filesize for a 64-bit system is actually 2<sup>63</sup>-1.</p>"},{"location":"Libraries/gtk/","title":"GTK","text":"<ol> <li>Without connecting the signals, the process will not terminate after clicking the close button, although the window will close.</li> </ol>"},{"location":"Libraries/ncurses/","title":"ncurses","text":"<pre><code># Compiling with ncurses library\ngcc -lncurses\n</code></pre> Hello, World!<pre><code>\n</code></pre> <ul> <li>initscr() initializes the terminal in curses mode and needs to be called first before doing any screen manipulation. The present window is called stdscr.</li> <li>printw() prints to coordinates (0,0) by default.</li> <li>refresh() is necessary because printw() actually prints to an imaginary window which does not become visible until refresh() is called. Omitting refresh() is a typical mistake committed by novices.</li> <li>endwin() frees memory taken by the curses subsystem and returns the terminal to normal mode. Failing to call this will cause problems with the terminal.</li> </ul>"},{"location":"Libraries/pthreads/","title":"pthread.h","text":"<p>pthread provides an API for multithreaded programming in C. New threads are spawned explicitly using pthread_create passing the name of a function which the thread will run.</p> <p>Notably, this function must have precisely the following signature:</p> <pre><code>void* func(void *arg)\n</code></pre> Compile a program with pthread<pre><code># Compile a program using pthread\ngcc -lpthread\n</code></pre>"},{"location":"Libraries/stdio.h/","title":"stdio.h","text":"<pre><code>// Open a file\nFILE*   fopen(const char *file_name, const char *access_mode);\n\n// Print a system error\nvoid    perror(const char *msg);\n\n// Print to STDOUT\nint     printf(const char* restrict format, ...);\n</code></pre>"},{"location":"Libraries/stdio.h/#printf","title":"printf","text":"<p>The placeholders within the string that are replaced by variable values are called specifiers.</p> <pre><code>printf(\"%-20s\", var); // Left-justified string at a width of 20 characters\n</code></pre>"},{"location":"Libraries/stdlib.h/","title":"stdlib.h","text":""},{"location":"Libraries/stdlib.h/#exit","title":"exit","text":"exit() ends the program, returning the integer provided in parentheses as the exit status of the process."},{"location":"Libraries/stdlib.h/#getpid","title":"getpid","text":"<pre><code>pid_t getpid(pidt);\n</code></pre> <pre><code>#include &lt;unistd.h&gt;\n\ngetpid();\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    int status;\n    if (fork()) {\n        printf(\"parent waiting for child ... \\n\");\n        wait(&amp;status);\n        if (WIFEXITED(status))\n            printf(\"child ended normally, exit status = %d\\n\", WEXITSTATUS(status));\n        if (WIFSIGNALED(status))\n            printf(\"child terminated by signal %d\\n\", WTERMSIG(status));\n    } else {\n        printf(\"child running -- PID is %d\\n\", getpid());\n        sleep(50);\n        exit(3);\n    }\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#getrandom","title":"getrandom","text":"Introduced in Linux 3.17 to allow userspace applications to request random numbers in the case of no access to random devices (i.e. containers). By default it will use the /dev/urandom pool, which normally does not block.  A flag can be provided to use the /dev/random pool instead."},{"location":"Libraries/stdlib.h/#malloc","title":"malloc","text":""},{"location":"Libraries/stdlib.h/#memcpy","title":"memcpy","text":"<p>Used for copying stack-allocated data.</p> <pre><code>memcpy(\n    dst,  //\n    size, //\n    flags //\n);\n</code></pre>"},{"location":"Libraries/stdlib.h/#mmap","title":"mmap","text":"<p>Maps a file into memory, allowing it to be accessed as if were an array. <pre><code>mmap(\n    addr,   // Commonly set to **NULL**, allowing the kernel to choose the address.\n    length, // Length of the mapping\n    prot,   // Typically a combination of **PROT\\_READ** and/or **PROT\\_WRITE**\n    flags,  // Determines whether the mapped region is shared with other processes: **MAP\\_SHARED** or **MAP\\_PRIVATE**\n    fd,     // File descriptor from [**open()**](#open)\n    offset  // Multiple of page size, and often set to 0 to map the entire file\n);  // Return value is the address to which the file has been mapped (similar to [**malloc()**](#malloc))\n</code></pre></p> IPC producerIPC consumer <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/mman.h&gt;\n\nint main() \n{\nconst int SIZE = 4096;              // size of shared memory object (bytes)\nconst char *name = \"OS\";            // name of shared memory object\nconst char *message_0 = \"Hello\";\nconst char *message_1 = \"World!\";\n\nint fd;     // shared memory file descriptor\nchar *ptr;  // pointer to shared memory object\n\n    // create the shared memory object\n    fd = shm_open(name, O_CREAT | O_RDWR, 0666); \n\n    // configure size of the shared memory object\n    ftruncate(fd, SIZE);    \n\n    // memory map the shared memory object\n    ptr = (char *) mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    // write to shared memory object\n    sprintf(ptr, \"%s\", message_0);\n    ptr += strlen(message_0);\n    sprintf(ptr, \"%s\", message_1);\n    ptr += strlen(message_1);\n\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/mman.h&gt;\n\nint main() \n{\nconst int SIZE = 4096;\nconst char *name = \"OS\";\nint fd;\nchar *ptr;\n\n    fd = shm_open(name, O_RDONLY, 0666);\n    ptr = (char *) mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    printf(\"%s\", (char *)ptr);\n\n    shm_unlink(name);\n\n    return 0;\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#msync","title":"msync","text":""},{"location":"Libraries/stdlib.h/#open","title":"open","text":"<p>A call to open() creates a new open file descriptor</p> <pre><code>fd = open(\"foo\", O_RDWR   | // (1) \n                O_TRUNC  | // (2) \n                O_APPEND   // (3)\n);\n</code></pre> <ol> <li>Access mode flag specifying reading and writing: O_RDWR, O_RDONLY, or O_WRONLY.</li> <li>Open-time flag required for writing. However, calling ftruncate() is recommended over use of this flag in open(), which is retained for backwards compatibility.</li> <li>Operating mode flag that makes all write operations write data at the end of the file, extending it, regardless of the current file position.</li> </ol> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define BSIZE 16384\n\nvoid main()\n{\n    int fin, fout;\n    char buf[BSIZE];\n    int count;\n\n    if ((fin = open(\"foo\", O_RDONLY)) &lt; 0) {\n        perror(\"foo\");\n        exit(1);\n    }\n    if ((fout = open(\"bar\", O_WRONLY | O_CREAT, 0644)) &lt; 0) {\n        perror(\"bar\");\n        exit(2);\n    }\n    while ((count = read(fin, buf, BSIZE)) &gt; 0)\n        write(fout, buf, count);\n\n    close(fin);\n    close(fout);\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#read","title":"read","text":"<p>Like write(), calls to read() require require a pointer to the buffer as well as the count of bytes which must not exceed the buffer's actual size. read() will return the number of bytes actually read and 0 on end-of-file. <pre><code>read(fd, buffer, count);\n</code></pre></p> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define BSIZE 16384\n\nvoid main()\n{\n    int fin, fout;\n    char buf[BSIZE];\n    int count;\n\n    if ((fin = open(\"foo\", O_RDONLY)) &lt; 0) {\n        perror(\"foo\");\n        exit(1);\n    }\n    if ((fout = open(\"bar\", O_WRONLY | O_CREAT, 0644)) &lt; 0) {\n        perror(\"bar\");\n        exit(2);\n    }\n    while ((count = read(fin, buf, BSIZE)) &gt; 0)\n        write(fout, buf, count);\n\n    close(fin);\n    close(fout);\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#rand","title":"rand","text":"<pre><code>int rand(RAND_MAX);\n</code></pre> <p>Generate a pseudo-random integer from 0 to RAND_MAX. A seed must first be provided to srand.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    srand(time(NULL));\n\n    int random_number = rand() % 2;\n    printf(\"Random number: %d\\n\", random_number);\n    return 0;\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#srand","title":"srand","text":"<p>Set a seed for a new sequence of pseud-orandom integers to be returned by rand.</p> Coin flip<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main(int argc, char const *argv[])\n{\n    srand(time(NULL));\n\n    int random_number = rand() % 2;\n    printf(\"Random number: %d\\n\", random_number);\n    return 0;\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#shm_open","title":"shm_open","text":"Coin flip<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/mman.h&gt;\n\nint main() \n{\nconst int SIZE = 4096;              // size of shared memory object (bytes)\nconst char *name = \"OS\";            // name of shared memory object\nconst char *message_0 = \"Hello\";\nconst char *message_1 = \"World!\";\n\nint fd;     // shared memory file descriptor\nchar *ptr;  // pointer to shared memory object\n\n    // create the shared memory object\n    fd = shm_open(name, O_CREAT | O_RDWR, 0666); \n\n    // configure size of the shared memory object\n    ftruncate(fd, SIZE);    \n\n    // memory map the shared memory object\n    ptr = (char *) mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    // write to shared memory object\n    sprintf(ptr, \"%s\", message_0);\n    ptr += strlen(message_0);\n    sprintf(ptr, \"%s\", message_1);\n    ptr += strlen(message_1);\n\n    return 0;\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#shm_unlink","title":"shm_unlink","text":"Removes the shared-memory segment after the consumer has accessed it. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/mman.h&gt;\n\nint main() \n{\nconst int SIZE = 4096;\nconst char *name = \"OS\";\nint fd;\nchar *ptr;\n\n    fd = shm_open(name, O_RDONLY, 0666);\n    ptr = (char *) mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    printf(\"%s\", (char *)ptr);\n\n    shm_unlink(name);\n\n    return 0;\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#wait","title":"wait","text":"<p>wait() blocks until one of the process's children terminates and returns an integer.</p> <pre><code>int status;\nwait(&amp;status); // (1)\n</code></pre> <ol> <li>Passing 0 or NULL will discard the child's exit status.</li> </ol> <p>The exit status is separted into upper and lower bytes. If the process was killed by a signal the top bit of the lower byte is called the \"Core Dumped\" flag. There are several macros used to analyze the exit status.</p> <ul> <li>WIFEXITED true if child exited normally</li> <li>WEXITSTATUS</li> <li>WIFSIGNALED true if child terminated by signal</li> <li>WTERMSIG signal number</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main()\n{\n    int status;\n    if (fork()) {\n        printf(\"parent waiting for child ... \\n\");\n        wait(&amp;status);\n        if (WIFEXITED(status))\n            printf(\"child ended normally, exit status = %d\\n\", WEXITSTATUS(status));\n        if (WIFSIGNALED(status))\n            printf(\"child terminated by signal %d\\n\", WTERMSIG(status));\n    } else {\n        printf(\"child running -- PID is %d\\n\", getpid());\n        sleep(50);\n        exit(3);\n    }\n}\n</code></pre> <pre><code>#include &lt;sys/types.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n  pid_t pid;\n\n  pid = fork();\n\n  if (pid &lt; 0) {\n    fprintf(stderr, \"Fork Failed\");\n    return 1;\n  } else if (pid == 0) {\n    execlp(\"/bin/ls\",\"ls\",NULL);\n  } else {\n    wait(NULL);\n    printf(\"Child complete\");\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"Libraries/stdlib.h/#write","title":"write","text":"<p>Like read(), write() takes an integer file descriptor, a pointer to the buffer, as well as a count of bytes which must not exceed the buffer's size.</p> <pre><code>write(fd, buffer, count);\n</code></pre> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define BSIZE 16384\n\nvoid main()\n{\n    int fin, fout;\n    char buf[BSIZE];\n    int count;\n\n    if ((fin = open(\"foo\", O_RDONLY)) &lt; 0) {\n        perror(\"foo\");\n        exit(1);\n    }\n    if ((fout = open(\"bar\", O_WRONLY | O_CREAT, 0644)) &lt; 0) {\n        perror(\"bar\");\n        exit(2);\n    }\n    while ((count = read(fin, buf, BSIZE)) &gt; 0)\n        write(fout, buf, count);\n\n    close(fin);\n    close(fout);\n}\n</code></pre>"},{"location":"Libraries/string.h/","title":"string.h","text":"<pre><code>//Return the length of a given string in bytes, excluding the terminating null byte \\0.\nsize_t  strlen  (const char* s);)\n</code></pre>"},{"location":"Libraries/unistd.h/","title":"unistd.h","text":"<pre><code>// Get current process ID\npid_t   getpid  (void);\n\n// Parse command-line arguments and options\nint     getopt  (int argc, char* argv[], const char* optstring)\n\n// Return a new file offset or -1 on error\noff_t   lseek   (int fd, off_t offset, int whence);\n\n// Returns number of bytes written, or -1 on error\nssize_t write   (int fd, void* buffer, size_t count);\n</code></pre> <ul> <li>close close a file descriptor</li> <li>exec create a new process</li> <li>fork create a new process</li> <li>open</li> <li>read</li> <li>select</li> <li>sleep</li> <li>swab</li> <li>write</li> </ul> <p>This library also defines the symbolic constants STDIN_FILENO, STDOUT_FILENO, and STDERR_FILENO.</p>"},{"location":"Libraries/unistd.h/#close","title":"close","text":"<pre><code>close(fd);\n</code></pre> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define BSIZE 16384\n\nvoid main()\n{\n    int fin, fout;\n    char buf[BSIZE];\n    int count;\n\n    if ((fin = open(\"foo\", O_RDONLY)) &lt; 0) {\n        perror(\"foo\");\n        exit(1);\n    }\n    if ((fout = open(\"bar\", O_WRONLY | O_CREAT, 0644)) &lt; 0) {\n        perror(\"bar\");\n        exit(2);\n    }\n    while ((count = read(fin, buf, BSIZE)) &gt; 0)\n        write(fout, buf, count);\n\n    close(fin);\n    close(fout);\n}\n</code></pre>"},{"location":"Libraries/unistd.h/#exec","title":"exec","text":"<p>There are seven variations of exec(), all of which are used to replace the current process with the contents of another thread.</p> <p>These variations are distinguished by:</p> <ul> <li>list or vector arguments</li> <li>whether or not they create a new environment and </li> <li>whether they require a full pathname or must search on the path environment variable</li> </ul> <p>For example, execvpe specifies an executable on the path, creates a new environment, and passes arguments in a vector.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n\nmain()\n{\n    char line[100];\n\n    while (printf(\"&gt; \"), gets(line) != NULL) \n    {\n        if (fork() == 0) {\n            execlp(line, line, (char *)0);\n            printf(\"%s: not found\\n\", line);\n            exit(1);\n        } \n        else \n            wait(0);\n    }\n}\n</code></pre>"},{"location":"Libraries/unistd.h/#fork","title":"fork","text":"<p>fork() is used to create a new process and is typically associated with exec() and wait().</p> <p>This simple example shows how the value returned by the fork() call differs between the parent and child processes.</p> <pre><code>#include &lt;stdio.h&gt;\n\nvoid main() {\n    if (fork()) // i.e. anything but 0\n        printf(\"I am the parent\\n\");\n    else \n        printf(\"I am the child\\n\");\n}\n</code></pre> <pre><code>#include &lt;sys/types.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n  pid_t pid;\n\n  pid = fork();\n\n  if (pid &lt; 0) {\n    fprintf(stderr, \"Fork Failed\");\n    return 1;\n  } else if (pid == 0) {\n    execlp(\"/bin/ls\",\"ls\",NULL);\n  } else {\n    wait(NULL);\n    printf(\"Child complete\");\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"Libraries/unistd.h/#ftruncate","title":"ftruncate","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/shm.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/mman.h&gt;\n\nint main() \n{\nconst int SIZE = 4096;              // size of shared memory object (bytes)\nconst char *name = \"OS\";            // name of shared memory object\nconst char *message_0 = \"Hello\";\nconst char *message_1 = \"World!\";\n\nint fd;     // shared memory file descriptor\nchar *ptr;  // pointer to shared memory object\n\n    // create the shared memory object\n    fd = shm_open(name, O_CREAT | O_RDWR, 0666); \n\n    // configure size of the shared memory object\n    ftruncate(fd, SIZE);    \n\n    // memory map the shared memory object\n    ptr = (char *) mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    // write to shared memory object\n    sprintf(ptr, \"%s\", message_0);\n    ptr += strlen(message_0);\n    sprintf(ptr, \"%s\", message_1);\n    ptr += strlen(message_1);\n\n    return 0;\n}\n</code></pre>"},{"location":"Libraries/unistd.h/#lseek","title":"lseek","text":"<p>Repositions the file read/write offset, allowing random access to an open file descriptor. <pre><code>#include &lt;unistd.h&gt;\n\nlseek(\n    fd, \n    offset, // (1)\n    whence  // (2)\n);\n</code></pre></p> <ol> <li>Byte offset, positive or negative (usually negative when with respect to end-of file using SEEK_END flag).</li> <li>Accepts one of several flags that determine where the offset is relative to: SEEK_SET (beginning of file), SEEK_CUR (current position), or SEEK_END (end of file).</li> </ol>"}]}